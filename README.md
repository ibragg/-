

Поскольку масть карт не учитывается заведем структуру карта, которая суть является значением карты без масти: 1 - 6, 2 - 7, ... , 8 - король, 9 - туз.
Также заведем структуру колода, в которой будем хранить 9 карт. 
И заведем структуру вершина которая будет хранить текущую конфигурацию раскладок 8 колод карт. В ней добавим функцию найти все вершины(конфигурации) в которые
можно попасть за ход.
При помощи которой получим граф игры состоящий из вершин(конфигураций раскладок). 
Решать будем при помощи функции findsolution, которая по сути алгоритм 
IDA* c некоторыми модификациями(использование dfs, который будет описан ниже, и еще будем удалять из хэш таблицы вершины которые находятся далеко от текущей,
которые мы давно положили в хэш таблицу, потому что их нет смысла хранить поскольку многие ходы в игре невозвратные, и их гораздо больше чем возвратных),
добавим вершины в очередь с приоритетом, и в цикле который не завершится пока очередь непуста будем 
выполнять следующие операции:
убираем из очереди вершину с наибольшим значением эвристики(поскольку зэвристика будет приоритетом), после чего проверяем корректность
этой вершины при помощи функции is_correct(),
и запускаем дфс из этой вершины, и кладем в очередь все корректные вершины. При этом посещенные вершины храним в хэш таблице, чтобы не было циклов.
При этом удаляем из очереди вершины с худшей эвристикой если нашли с лучшей. Эвристикой выберем следующее значение - будем считать количество хорошо лежащих
карт суммарно( набор карт в куче , хорошо лежащий, если все карты под первой в этом наборе в нем идут в порядке возрастания).
Далее проверяем является ли вершина ответом,
после чего добавляем ее в стек-путь 
по которому мы пришли к этой вершине. Для каждой вершины которую мы достаем из очереди проверяем при помощи функции is_ans является данная конфигурация 
пасьянса выигрышной. Если мы нашли вершину для которой is_ans правда, и алгоритм еще не завершился то мы смогли получить верную раскладку, если нет то
проиграли.
